#!@php_bin@
<?php
/**
 * Script to recursively find all JPG's in a directory and attempt to optimize
 * them. (Does not remove EXIF metadata; tool only optimizes Huffman coding).
 *
 * Jpegtran binary from the standard libjpeg library (http://ijg.org).
 *
 * Usage: horde-compress-jpgs -d [directory]
 *                            -j [jpegtran binary]
 *
 * Copyright 2011-2013 The Horde Project (http://www.horde.org/)
 *
 * See the enclosed file COPYING for license information (LGPL). If you
 * did not receive this file, see http://www.fsf.org/copyleft/lgpl.html.
 *
 * @author   Michael Slusarz <slusarz@horde.org>
 * @category Horde
 * @license  http://www.fsf.org/copyleft/lgpl.html LGPL
 * @package  maintainer_tools
 */

require_once 'Horde/Autoloader/Default.php';

$parser = new Horde_Argv_Parser(array(
    'usage' => "%prog\n\t[--directory=path]\n\t--jpegtran=path",
    'optionList' => array(
        new Horde_Argv_Option('-d', '--directory', array(
            'default' => getcwd(),
            'help' => 'Directory to recursively parse'
        )),
        new Horde_Argv_Option('-j', '--jpegtran', array(
            'help' => 'Location of jpegtran binary'
        ))
    )
));
list($args,) = $parser->parseArgs();

if (!$args->jpegtran || !is_executable($args->jpegtran)) {
    $parser->parserError("Invalid arguments.");
}

$it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($args->directory, RecursiveIteratorIterator::SELF_FIRST));
while ($it->valid()) {
    if ($it->isFile() &&
        (strcasecmp('.jpg', substr($it->key(), -4)) === 0)) {
        $file = realpath($it->key());
        $jpeg = '';
        $start_size = $it->getSize();

        $fp = popen($args->jpegtran . ' -optimize ' . escapeshellarg($file), 'r');
        while (!feof($fp)) {
            $jpeg .= fread($fp, 8192);
        }
        fclose($fp);

        $end_size = strlen($jpeg);
        if ($end_size < $start_size) {
            file_put_contents($file, $jpeg);
            print $file . ":\n" .
                  '    ' . $start_size . ' => ' . $end_size . ' (' . round((($start_size - $end_size) / $start_size) * 100, 1) . "%)\n";
        }
    }
    $it->next();
}
